The trace content generated by the hack branch. The command used is:
sudo ./build/release/tests/udp_client --network-stack native --dpdk-pmd --dhcp no --smp 2

Registering stack
Registering stack
Install signal handlers
We are using DPDK PMD
The main thread id is 140491762215616
Number of the CPUs on this machine is 20
It seems that we are in this more complicated version of allocate
available_memory: 25280389120
Calculated mem: 23510761856
procs: 2, available_procs: 20
CPU id: 0
The 0th memory size in bytes: 11754536960, nodeid: 0
CPU id: 10
The 0th memory size in bytes: 11754536960, nodeid: 0
io queues
0 1
0,128 1,128
Pinning the master(first) thread
Configure memory for the master(first) thread
hugetlbfs_path is not set
huge_page_size:2097152
new_size:11754536960
nr_pages:8192
page_size:4096
tmp_size:134217728
tmp_size:536870912
tmp_size:2147483648
tmp_size:8589934592
tmp_size:11754536960
EAL: Detected 20 lcore(s)
EAL: No free hugepages reported in hugepages-1048576kB
EAL: Probing VFIO support...
EAL: WARNING: cpu flags constant_tsc=yes nonstop_tsc=no -> using unreliable clock cycles !
EAL: PCI device 0000:00:0a.0 on NUMA socket -1
EAL:   probe driver: 8086:1572 net_i40e
PMD: eth_i40e_dev_init(): FW 4.40 API 1.4 NVM 04.05.03 eetrack 80001e5b
Thread 0: Start constructing the reactor
On thread count 1: start to create the thread
hugetlbfs_path is not set
huge_page_size:2097152
new_size:11754536960
nr_pages:8192
page_size:4096
tmp_size:134217728
tmp_size:536870912
tmp_size:2147483648
tmp_size:8589934592
tmp_size:11754536960
Thread 1: Start constructing the reactor
Thread 0: start setting up the qs
Thread 0: start setting up smp queues and io queue
Thread 1: start setting up smp queues and io queue
Thread 1: start engine configuration, especially for the network stack
Thread 0: start engine configuration, especially for the network stack
Thread 0: Start creating the native network stack
Thread 0: constructing the native-network device
ports number: 1
Thread 0: Create a dpdk_device. Physical port id 0, queue number 2.
Thread 0: Unfortunately, Seastar only supports a single dpdk_device.
Device is an net_i40e
Port 0: max_rx_queues 320 max_tx_queues 320
Port 0: using 2 queues
Port 0: RSS table size is 512
_use_lro is true
LRO is off
RX checksum offload supported
TX ip checksum offload supported
TSO is supported
TX TCP&UDP checksum offload supported
Port 0 init ... Thread 1: Start creating the native network stack
done:
hw_features.tx_csum_ip_offload: 1
hw_features.tx_csum_l4_offload: 1
hw_features.rx_csum_offload: 1
hw_features.rx_lro: 0
hw_features.tx_tso: 1
hw_features.tx_ufo: 0
hw_features.mtu: 1500
hw_features.max_packet_len: 65521
Thread 0: Creating a shared pointer for the dpdk_device.
Thread 0: prepare to set up the queue for the dpdk device.
Thread 0: queue id is smaller than hw_queues_count
Thread 0: Creating Tx mbuf pool 'dpdk_pktmbuf_pool0_tx' [1024 mbufs] ...
Thread 0: Constructing dpdk_qp for queue 0
Thread 0: Creating Rx mbuf pool 'dpdk_pktmbuf_pool0_rx' [1024 mbufs] ...
Thread 1: prepare to set up the queue for the dpdk device.
Thread 1: queue id is smaller than hw_queues_count
Thread 1: Creating Tx mbuf pool 'dpdk_pktmbuf_pool1_tx' [1024 mbufs] ...
Thread 1: Constructing dpdk_qp for queue 1
Thread 1: Creating Rx mbuf pool 'dpdk_pktmbuf_pool1_rx' [1024 mbufs] ...
Thread 0: Port 0: Enabling HW FC
Thread 0: Before rte_eth_dev_start
PMD: i40e_pf_config_rss(): Max of contiguous 2 PF queues are configured
Thread 0: After rte_eth_dev_start
Port 0: HASH FILTER configuration is supported
Thread 0: Finish setting up the rss table

Checking link status from thread 0
Created DPDK device
.............done
Port 0 Link Up - speed 10000 Mbps - full-duplex
Thread 0: _link_ready_promise is set
Thread 0: _link_ready_promise is set, start to create the native stack
Thread 0: device::receive is called to add a listen function to the qp's _rx_stream
Thread 0: dpdk_qp::rx_start is called. A poller is constructed with poll_rx_once() as polling function
Thread 0: Construct interface, register_packet_provider is called for local_queue
Thread 0: l3_protocol::receive is called
Thread 0: the listen function for l3 rx stream is set to handle_received_packet
Thread 0: constructing arp
Thread 0: l3_protocol::receive is called
Thread 0: the listen function for l3 rx stream is set to handle_received_packet
Thread 0: Constructing the native_network_stack
Thread 0: dhcp is not set, set some default value for _net
Thread 0: finish constructing native_network_stack
Thread 0: native_network_stack::ready_promise is set
Thread 0: _network_stack_ready_promise is set
Thread 0: Sending out _cpu_started.signal() to each CPU core
Thread 1: device::receive is called to add a listen function to the qp's _rx_stream
Thread 1: dpdk_qp::rx_start is called. A poller is constructed with poll_rx_once() as polling function
Thread 1: Construct interface, register_packet_provider is called for local_queue
Thread 1: l3_protocol::receive is called
Thread 1: the listen function for l3 rx stream is set to handle_received_packet
Thread 1: constructing arp
Thread 1: l3_protocol::receive is called
Thread 1: the listen function for l3 rx stream is set to handle_received_packet
Thread 1: Constructing the native_network_stack
Thread 1: dhcp is not set, set some default value for _net
Thread 1: finish constructing native_network_stack
Thread 1: native_network_stack::ready_promise is set
Thread 1: _network_stack_ready_promise is set
Thread 1: Sending out _cpu_started.signal() to each CPU core
Thread 1: reactor::_cpu_started is set, start to initialize the _network_stack
Thread 1: native_network_stack::initialize() is called
Thread 1: a ready future is directed returned after native_network_stack::initialize
Thread 0: reactor::_cpu_started is set, start to initialize the _network_stack
Thread 0: native_network_stack::initialize() is called
Thread 0: a ready future is directed returned after native_network_stack::initialize
Thread 0: when_started() is called
Thread 0: It seems that an exception is thrown in this stage
App code: Inside udo_client
program failed with uncaught exception: boost::bad_any_cast: failed conversion using boost::any_cast
