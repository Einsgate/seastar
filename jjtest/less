getting-started.cc:11:27: error: invalid use of template-name ‘seastar::temporary_buffer’ without an argument list
  using temporary_buffer = seastar::temporary_buffer;
                           ^
getting-started.cc:14:2: error: ‘input_stream’ does not name a type
  input_stream<char> read_buf;
  ^
getting-started.cc:15:5: error: ‘output_stream’ does not name a type
     output_stream<char> write_buf;
     ^
getting-started.cc:16:5: error: ‘temporary_buffer’ does not name a type
     temporary_buffer<char> readline_buf;
     ^
getting-started.cc:17:5: error: ‘temporary_buffer’ does not name a type
     temporary_buffer<char> readline_buf_ret;
     ^
getting-started.cc: In constructor ‘http_proxy_conn_s::http_proxy_conn_s(http_proxy_conn_s::connected_socket&&, http_proxy_conn_s::socket_address&&)’:
getting-started.cc:19:102: error: class ‘http_proxy_conn_s’ does not have any field named ‘read_buf’
  http_proxy_conn_s(connected_socket &&s, socket_address &&a) : fd(std::move(s)), addr(std::move(a)), read_buf(fd.input()), 
                                                                                                      ^
getting-started.cc:20:5: error: class ‘http_proxy_conn_s’ does not have any field named ‘write_buf’
     write_buf(fd.output()) {
     ^
getting-started.cc:22:6: error: ‘readline_index’ was not declared in this scope
      readline_index = -1;
      ^
getting-started.cc: In lambda function:
getting-started.cc:35:13: error: ‘this’ was not captured for this lambda function
   read_line().then([] () {
             ^
getting-started.cc:35:13: error: cannot call member function ‘seastar::future<> http_proxy_conn_s::read_line()’ without object
getting-started.cc: In lambda function:
getting-started.cc:36:11: error: ‘readline_buf_ret’ was not declared in this scope
    fwrite(readline_buf_ret.begin(), readline_buf_ret.size(), 1, stdout);
           ^
getting-started.cc: In lambda function:
getting-started.cc:47:6: error: ‘readline_buf’ was not declared in this scope
   if(readline_buf){
      ^
getting-started.cc:50:7: error: ‘ptr’ was not declared in this scope
    if(ptr){
       ^
getting-started.cc:51:5: error: ‘temporary_buffer’ was not declared in this scope
     temporary_buffer<char> ret_buf{buf_begin, ptr - buf_begin + 1};
     ^
getting-started.cc:51:5: note: suggested alternative:
In file included from /home/net/async-nf/seastar/core/sstring.hh:38:0,
                 from /home/net/async-nf/seastar/core/seastar.hh:44,
                 from getting-started.cc:1:
/home/net/async-nf/seastar/core/temporary_buffer.hh:61:7: note:   ‘seastar::temporary_buffer’
 class temporary_buffer {
       ^
getting-started.cc:51:22: error: expected primary-expression before ‘char’
     temporary_buffer<char> ret_buf{buf_begin, ptr - buf_begin + 1};
                      ^
getting-started.cc:53:5: error: ‘readline_buf_ret’ was not declared in this scope
     readline_buf_ret = std::move(ret_buf);
     ^
getting-started.cc:53:34: error: ‘ret_buf’ was not declared in this scope
     readline_buf_ret = std::move(ret_buf);
                                  ^
getting-started.cc:48:16: error: unused variable ‘buf_begin’ [-Werror=unused-variable]
    const char *buf_begin = readline_buf.begin()
                ^
getting-started.cc:58:3: error: ‘read_buf’ was not declared in this scope
   read_buf.read().then([] (auto buf) {
   ^
getting-started.cc: In lambda function:
getting-started.cc:59:8: error: ‘readline_buf’ was not declared in this scope
    if(!readline_buf){ 
        ^
getting-started.cc:63:5: error: ‘temporary_buffer’ was not declared in this scope
     temporary_buffer<char> temp_buf{buf.size() + readline_buf.size()}
     ^
getting-started.cc:63:5: note: suggested alternative:
In file included from /home/net/async-nf/seastar/core/sstring.hh:38:0,
                 from /home/net/async-nf/seastar/core/seastar.hh:44,
                 from getting-started.cc:1:
/home/net/async-nf/seastar/core/temporary_buffer.hh:61:7: note:   ‘seastar::temporary_buffer’
 class temporary_buffer {
       ^
getting-started.cc:63:22: error: expected primary-expression before ‘char’
     temporary_buffer<char> temp_buf{buf.size() + readline_buf.size()}
                      ^
getting-started.cc:64:26: error: ‘temp_buf’ was not declared in this scope
     char *temp_buf_ptr = temp_buf.get_write();
                          ^
In file included from getting-started.cc:2:0:
/home/net/async-nf/seastar/core/future-util.hh: In instantiation of ‘seastar::future<> seastar::repeat(AsyncAction&&) [with AsyncAction = http_proxy_conn_s::handle()::<lambda()>]’:
getting-started.cc:42:3:   required from here
/home/net/async-nf/seastar/core/future-util.hh:166:5: error: static assertion failed: bad AsyncAction signature
     static_assert(std::is_same<future<stop_iteration>, typename futurator::type>::value, "bad AsyncAction signature");
     ^
/home/net/async-nf/seastar/core/future-util.hh:179:18: error: no matching function for call to ‘seastar::future<>::then(seastar::repeat(AsyncAction&&) [with AsyncAction = http_proxy_conn_s::handle()::<lambda()>]::<lambda(seastar::stop_iteration)>)’
                 });
                  ^
In file included from /home/net/async-nf/seastar/core/seastar.hh:45:0,
                 from getting-started.cc:1:
/home/net/async-nf/seastar/core/future.hh:884:5: note: candidate: template<class Func, class Result> Result seastar::future<T>::then(Func&&) [with Func = Func; Result = Result; T = {}]
     then(Func&& func) noexcept {
     ^
/home/net/async-nf/seastar/core/future.hh:884:5: note:   template argument deduction/substitution failed:
/home/net/async-nf/seastar/core/future.hh:881:30: error: no type named ‘type’ in ‘class std::result_of<seastar::repeat(AsyncAction&&) [with AsyncAction = http_proxy_conn_s::handle()::<lambda()>]::<lambda(seastar::stop_iteration)>()>’
     template <typename Func, typename Result = futurize_t<std::result_of_t<Func(T&&...)>>>
                              ^
In file included from getting-started.cc:2:0:
/home/net/async-nf/seastar/core/future-util.hh:182:26: error: no match for ‘operator==’ (operand types are ‘seastar::future_state<>::get0_return_type {aka void}’ and ‘const seastar::bool_class<seastar::stop_iteration_tag>’)
             if (f.get0() == stop_iteration::yes) {
                          ^
In file included from /home/net/async-nf/seastar/core/future-util.hh:30:0,
                 from getting-started.cc:2:
/home/net/async-nf/seastar/core/shared_ptr.hh:676:1: note: candidate: template<class T> bool seastar::operator==(std::nullptr_t, const seastar::shared_ptr<T>&)
 operator==(std::nullptr_t, const shared_ptr<T>& y) {
 ^
/home/net/async-nf/seastar/core/shared_ptr.hh:676:1: note:   template argument deduction/substitution failed:
In file included from getting-started.cc:2:0:
/home/net/async-nf/seastar/core/future-util.hh:182:26: note:   cannot convert ‘f.seastar::future<T>::get0<{}>()’ (type ‘seastar::future_state<>::get0_return_type {aka void}’) to type ‘std::nullptr_t’
             if (f.get0() == stop_iteration::yes) {
                          ^
In file included from /home/net/async-nf/seastar/core/future-util.hh:30:0,
                 from getting-started.cc:2:
/home/net/async-nf/seastar/core/shared_ptr.hh:669:1: note: candidate: template<class T> bool seastar::operator==(const seastar::shared_ptr<T>&, std::nullptr_t)
 operator==(const shared_ptr<T>& x, std::nullptr_t) {
 ^
/home/net/async-nf/seastar/core/shared_ptr.hh:669:1: note:   template argument deduction/substitution failed:
In file included from getting-started.cc:2:0:
/home/net/async-nf/seastar/core/future-util.hh:182:26: note:   mismatched types ‘const seastar::shared_ptr<T>’ and ‘seastar::future_state<>::get0_return_type {aka void}’
             if (f.get0() == stop_iteration::yes) {
                          ^
In file included from /home/net/async-nf/seastar/core/future-util.hh:30:0,
                 from getting-started.cc:2:
/home/net/async-nf/seastar/core/shared_ptr.hh:662:1: note: candidate: template<class T, class U> bool seastar::operator==(const seastar::shared_ptr<T>&, const seastar::shared_ptr<U>&)
 operator==(const shared_ptr<T>& x, const shared_ptr<U>& y) {
 ^
/home/net/async-nf/seastar/core/shared_ptr.hh:662:1: note:   template argument deduction/substitution failed:
In file included from getting-started.cc:2:0:
/home/net/async-nf/seastar/core/future-util.hh:182:26: note:   mismatched types ‘const seastar::shared_ptr<T>’ and ‘seastar::future_state<>::get0_return_type {aka void}’
             if (f.get0() == stop_iteration::yes) {
                          ^
In file included from /home/net/async-nf/seastar/core/future-util.hh:33:0,
                 from getting-started.cc:2:
/home/net/async-nf/seastar/util/bool_class.hh:88:17: note: candidate: bool seastar::operator==(seastar::bool_class<seastar::stop_iteration_tag>, seastar::bool_class<seastar::stop_iteration_tag>)
     friend bool operator==(bool_class x, bool_class y) noexcept {
                 ^
/home/net/async-nf/seastar/util/bool_class.hh:88:17: note:   no known conversion for argument 1 from ‘seastar::future_state<>::get0_return_type {aka void}’ to ‘seastar::bool_class<seastar::stop_iteration_tag>’
In file included from /home/net/async-nf/seastar/core/seastar.hh:45:0,
                 from getting-started.cc:1:
/home/net/async-nf/seastar/core/future.hh: At global scope:
/home/net/async-nf/seastar/core/future.hh:1294:31: error: ‘static seastar::futurize<void>::type seastar::futurize<void>::apply(Func&&, FuncArgs&& ...) [with Func = http_proxy_conn_s::handle()::<lambda()>&; FuncArgs = {}; seastar::futurize<void>::type = seastar::future<>]’, declared using local type ‘http_proxy_conn_s::handle()::<lambda()>’, is used but never defined [-fpermissive]
 typename futurize<void>::type futurize<void>::apply(Func&& func, FuncArgs&&... args) noexcept {
                               ^
In file included from /home/net/async-nf/seastar/core/future.hh:26:0,
                 from /home/net/async-nf/seastar/core/seastar.hh:45,
                 from getting-started.cc:1:
/home/net/async-nf/seastar/core/task.hh:49:1: error: ‘std::unique_ptr<seastar::task> seastar::make_task(Func&&) [with Func = seastar::repeat(AsyncAction&&) [with AsyncAction = http_proxy_conn_s::handle()::<lambda()>]::<lambda()>]’, declared using local type ‘seastar::repeat(AsyncAction&&) [with AsyncAction = http_proxy_conn_s::handle()::<lambda()>]::<lambda()>’, is used but never defined [-fpermissive]
 make_task(Func&& func) {
 ^
getting-started.cc: In lambda function:
getting-started.cc:73:2: error: control reaches end of non-void function [-Werror=return-type]
  });
  ^
cc1plus: all warnings being treated as errors
